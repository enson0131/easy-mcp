{"version":3,"sources":["../src/mcp.ts","../src/utils/utils.ts","../src/cli.ts"],"sourcesContent":["import { FastMCP } from \"fastmcp\";\r\nimport { z } from \"zod\";\r\nimport { AsyncSeriesHook } from \"./utils/utils\";\r\nimport { resolve } from \"path\";\r\n\r\nexport interface ILanguageMcpConfig {\r\n  projectId: string; // 项目id\r\n  env: string; // 环境\r\n  path?: string; // 路径\r\n  language?: string; // 语言\r\n  languageCode?: string; // 语言代码\r\n  languageName?: string; // 语言名称\r\n}\r\n\r\ninterface IChainResult {\r\n  options: ILanguageMcpConfig,\r\n  server: FastMCP\r\n}\r\n\r\n/**\r\n * 从命令行、配置环境、函数参数中获取项目配置文件\r\n */\r\nconst initConfig = (options?: ILanguageMcpConfig) => {\r\n  let mergeOptions = {} as ILanguageMcpConfig;\r\n  // 1. 获取配置文件的参数\r\n  const configPath = resolve(process.cwd(), \".language-mcp.js\");\r\n  const configJsonByFile = require(configPath);\r\n\r\n\r\n  // 2. 获取命令行的参数\r\n  console.log(`process.argv -->`, process.argv) \r\n\r\n  // 3. 获取函数上的参数，进行合并\r\n  mergeOptions = Object.assign({}, configJsonByFile, options || {});\r\n  return mergeOptions\r\n}\r\n\r\nconst createServer = (options) => {\r\n  const server = new FastMCP({\r\n    name: \"language-mcp\", // 服务名称\r\n    version: \"1.0.0\",\r\n  });\r\n  \r\n  return {\r\n    options,\r\n    server,\r\n  } as IChainResult;\r\n}\r\n\r\nconst addGetLanguageTools = (lastResult: IChainResult) => {\r\n  const { server, options } = lastResult\r\n  // 获取语言列表的工具函数\r\n  server.addTool({\r\n    name: \"get_language_list\",\r\n    description: \"获取语言列表\",\r\n    parameters: z.object({\r\n      //   project_id: z.string(), // 项目id\r\n      //   path: z.string(), // 路径\r\n    }),\r\n    execute: async (args) => {\r\n      // \r\n      console.log(\"options\");\r\n      return \"hello Language MCP\";\r\n    },\r\n  });\r\n\r\n  return lastResult;\r\n}\r\n\r\n\r\nconst startServer = async (options?: ILanguageMcpConfig) => {\r\n  const asyncSeries = new AsyncSeriesHook();\r\n  const init = async () => await initConfig(options)\r\n  \r\n  const pips = [init, createServer, addGetLanguageTools];\r\n\r\n  for(let pipsOperation of pips) {\r\n    asyncSeries.next(pipsOperation);\r\n  }\r\n\r\n  const pro =  asyncSeries.run()\r\n\r\n  pro.catch(err => {\r\n    console.error(`[ERROR]`, err);\r\n  })\r\n\r\n  return pro;\r\n}\r\n\r\nexport default startServer;","\r\n/**\r\n * 请求重试\r\n */\r\nexport const retry = async (fn: () => any, count = 3) => {\r\n    return new Promise(async (resolve, reject) => {\r\n      while (count > 0) {\r\n        try {\r\n          const res = await fn();\r\n          resolve(res);\r\n          break;\r\n        } catch (error) {\r\n          count--;\r\n          if (count === 0) {\r\n            reject(error);\r\n          }\r\n      }\r\n    }});\r\n  }\r\n  \r\n  \r\nexport class AsyncSeriesHook {\r\n    tasks: Function[];\r\n    constructor() {\r\n      this.tasks = [];\r\n    }\r\n  \r\n    next(task: Function) {\r\n      this.tasks.push(task);\r\n      return this;\r\n    }\r\n  \r\n    callAsync(...args: any) {\r\n      const finalCallback = args.pop();\r\n      // @ts-ignore\r\n      const next = (idx: number, lastResult = null) => {\r\n        if (idx === this.tasks.length) {\r\n          finalCallback(lastResult, null);\r\n          return;\r\n        }\r\n        const task = this.tasks[idx];\r\n        task(lastResult, ...args).then(\r\n          (res: any) => {\r\n            next(idx + 1, res);\r\n          },\r\n          (err: any) => finalCallback(null, err),\r\n        );\r\n      };\r\n      next(0);\r\n    }\r\n  \r\n    run(...args: any) {\r\n      return new Promise<any>((resolve, reject) => {\r\n        const finalCallback = (res: any, err: any) => {\r\n          if (err) {\r\n            reject(err);\r\n          } else {\r\n            resolve(res);\r\n          }\r\n        };\r\n        this.callAsync(...args, finalCallback);\r\n      });\r\n    }\r\n}\r\n  \r\n  \r\n  // 使用方法\r\n  // const testhook = new AsyncSeriesHook(['param1', 'param2']); // 构造函数里面是参数名称，参数个数任意\r\n  // // lastTaskResult表示上个任务的返回\r\n  // testhook.next(async (lastTaskResult, param1, param2) => {\r\n  //   console.log('任务1', param1, param2);\r\n  //   await Promise.resolve('hook1');\r\n  //   return 'result1';\r\n  // });\r\n  // testhook.next(async (lastTaskResult, param1, param2) => {\r\n  //   console.log('任务2', param1, param2, lastTaskResult);\r\n  //   await Promise.resolve('hook2');\r\n  //   // return Promise.reject('hook2 reject'); // 如果返回reject，则不会往下执行后面的任务\r\n  //   return 'result2';\r\n  // });\r\n  // testhook.next(async (lastTaskResult, param1, param2) => {\r\n  //   console.log('任务3', param1, param2, lastTaskResult);\r\n  //   await Promise.resolve('hook3');\r\n  //   return 'result3';\r\n  // });\r\n  \r\n  // const param1 = { sum: 0 };\r\n  // const param2 = 'test';\r\n  // // param1,param2是传递给各个任务的参数\r\n  // testhook.run(param1, param2).then(\r\n  //   res => {\r\n  //     // res是最后一个任务的返回值\r\n  //     console.log('最终回调', res);\r\n  //   },\r\n  //   err => {\r\n  //     // 如果有任意一个任务失败都会中断后面所有任务的执行，并将错误通过Err跑出\r\n  //     console.log('有错误了。。。', err);\r\n  //   },\r\n  // );\r\n  ","#!/usr/bin/env node\r\nimport startServer, { ILanguageMcpConfig } from './mcp';\r\n\r\n\r\nexport function start (options?: ILanguageMcpConfig) {\r\n  return startServer(options).catch((error) => {\r\n    console.error(\"Failed to start server:\", error);\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\n// If we're being executed directly (not imported), start the server\r\nif (process.argv[1]) {\r\n  start();\r\n}\r\n"],"mappings":";;;;;;;;AAAA,SAAS,eAAe;AACxB,SAAS,SAAS;;;ACoBX,IAAM,kBAAN,MAAsB;AAAA,EACzB;AAAA,EACA,cAAc;AACZ,SAAK,QAAQ,CAAC;AAAA,EAChB;AAAA,EAEA,KAAK,MAAgB;AACnB,SAAK,MAAM,KAAK,IAAI;AACpB,WAAO;AAAA,EACT;AAAA,EAEA,aAAa,MAAW;AACtB,UAAM,gBAAgB,KAAK,IAAI;AAE/B,UAAM,OAAO,CAAC,KAAa,aAAa,SAAS;AAC/C,UAAI,QAAQ,KAAK,MAAM,QAAQ;AAC7B,sBAAc,YAAY,IAAI;AAC9B;AAAA,MACF;AACA,YAAM,OAAO,KAAK,MAAM,GAAG;AAC3B,WAAK,YAAY,GAAG,IAAI,EAAE;AAAA,QACxB,CAAC,QAAa;AACZ,eAAK,MAAM,GAAG,GAAG;AAAA,QACnB;AAAA,QACA,CAAC,QAAa,cAAc,MAAM,GAAG;AAAA,MACvC;AAAA,IACF;AACA,SAAK,CAAC;AAAA,EACR;AAAA,EAEA,OAAO,MAAW;AAChB,WAAO,IAAI,QAAa,CAACA,UAAS,WAAW;AAC3C,YAAM,gBAAgB,CAAC,KAAU,QAAa;AAC5C,YAAI,KAAK;AACP,iBAAO,GAAG;AAAA,QACZ,OAAO;AACL,UAAAA,SAAQ,GAAG;AAAA,QACb;AAAA,MACF;AACA,WAAK,UAAU,GAAG,MAAM,aAAa;AAAA,IACvC,CAAC;AAAA,EACH;AACJ;;;AD5DA,SAAS,eAAe;AAmBxB,IAAM,aAAa,CAAC,YAAiC;AACnD,MAAI,eAAe,CAAC;AAEpB,QAAM,aAAa,QAAQ,QAAQ,IAAI,GAAG,kBAAkB;AAC5D,QAAM,mBAAmB,UAAQ,UAAU;AAI3C,UAAQ,IAAI,oBAAoB,QAAQ,IAAI;AAG5C,iBAAe,OAAO,OAAO,CAAC,GAAG,kBAAkB,WAAW,CAAC,CAAC;AAChE,SAAO;AACT;AAEA,IAAM,eAAe,CAAC,YAAY;AAChC,QAAM,SAAS,IAAI,QAAQ;AAAA,IACzB,MAAM;AAAA;AAAA,IACN,SAAS;AAAA,EACX,CAAC;AAED,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAM,sBAAsB,CAAC,eAA6B;AACxD,QAAM,EAAE,QAAQ,QAAQ,IAAI;AAE5B,SAAO,QAAQ;AAAA,IACb,MAAM;AAAA,IACN,aAAa;AAAA,IACb,YAAY,EAAE,OAAO;AAAA;AAAA;AAAA,IAGrB,CAAC;AAAA,IACD,SAAS,OAAO,SAAS;AAEvB,cAAQ,IAAI,SAAS;AACrB,aAAO;AAAA,IACT;AAAA,EACF,CAAC;AAED,SAAO;AACT;AAGA,IAAM,cAAc,OAAO,YAAiC;AAC1D,QAAM,cAAc,IAAI,gBAAgB;AACxC,QAAM,OAAO,YAAY,MAAM,WAAW,OAAO;AAEjD,QAAM,OAAO,CAAC,MAAM,cAAc,mBAAmB;AAErD,WAAQ,iBAAiB,MAAM;AAC7B,gBAAY,KAAK,aAAa;AAAA,EAChC;AAEA,QAAM,MAAO,YAAY,IAAI;AAE7B,MAAI,MAAM,SAAO;AACf,YAAQ,MAAM,WAAW,GAAG;AAAA,EAC9B,CAAC;AAED,SAAO;AACT;AAEA,IAAO,cAAQ;;;AErFR,SAAS,MAAO,SAA8B;AACnD,SAAO,YAAY,OAAO,EAAE,MAAM,CAAC,UAAU;AAC3C,YAAQ,MAAM,2BAA2B,KAAK;AAC9C,YAAQ,KAAK,CAAC;AAAA,EAChB,CAAC;AACH;AAGA,IAAI,QAAQ,KAAK,CAAC,GAAG;AACnB,QAAM;AACR;","names":["resolve"]}